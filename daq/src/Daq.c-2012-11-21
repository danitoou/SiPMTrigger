#include <stdlib.h>
#include <stdio.h>
#include "CAENDigitizer.h"
#include <time.h>
#include <sys/stat.h>
#include <math.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/time.h>

//#include "Daq.h"

#define INT_N_EVENTS 10
#define USE_INTERRUPTS
#define N_READS   1000

typedef struct config_s {
  char cfg_file;
  int nchan;
  short int chmask;
  
}  config_t;


int read_config(char *fname,config_t *cfg){
  if (cfg == NULL) {
    
  }

}


double time_diff(struct timeval *t1,struct timeval *t2) {
  //  time_difference in microseconds:
  return  (( (double) t2->tv_sec -(double) t1->tv_sec)*1000000. + ((double)t2->tv_usec - (double)t1->tv_usec))/ 1000000.;
  
}


int main(int argc,char **argv) {
 
  CAEN_DGTZ_ErrorCode ret;
  
  int	handle;
  CAEN_DGTZ_BoardInfo_t BoardInfo;
  CAEN_DGTZ_EventInfo_t eventInfo;
  int board_id=0;
  //  CAEN_DGTZ_UINT16_EVENT_t *Evt = NULL;
  void *Evt = NULL;
  char *buffer = NULL;
  

  int i,b,k;
  int c = 0, count=0;
  char * evtptr = NULL;
  uint32_t size,bsize;
  uint32_t numEvents;
  uint32_t data;
  uint32_t reg;

  int filehandle;
  char ofname[256];

  uint32_t mybufsize;
  char *mybuf=NULL;
  int *mybsize=NULL;
  int pos=0;

  double tot_size=0.;
  
  
  time_t tim;
  struct tm *tt;
  time_t tbeg;
  time_t tend;

  struct timeval tv_beg;
  struct timeval tv_end;
  double dt;
  
  int iprev_ev=-1;
  int nmissed_ev=0;



  i = sizeof(CAEN_DGTZ_TriggerMode_t);
  
  
  //Using only 1 board
  ret |= CAEN_DGTZ_OpenDigitizer(CAEN_DGTZ_PCI_OpticalLink,0,0,0,&handle);
  //0xAAAA0000 - not necessary and not used, but let it have 
  if(ret != CAEN_DGTZ_Success) {
    printf("Can't open digitizer\n");
    return 0;
  }
  
  //Board opened successfully!
  ret |= CAEN_DGTZ_GetInfo(handle, &BoardInfo);
  printf("\nConnected to CAEN Digitizer Model %s\n", BoardInfo.ModelName);
  printf("\tROC FPGA Release is %s\n", BoardInfo.ROC_FirmwareRel);
  printf("\tAMC FPGA Release is %s\n", BoardInfo.AMC_FirmwareRel);


  //Configure the board
  ret |= CAEN_DGTZ_Reset(handle);                                               /* Reset Digitizer */
  ret |= CAEN_DGTZ_GetInfo(handle, &BoardInfo);                                 /* Get Board Info */
  printf("\nBoard info after reset\n");
  printf("\tROC FPGA Release is %s\n", BoardInfo.ROC_FirmwareRel);
  printf("\tAMC FPGA Release is %s\n", BoardInfo.AMC_FirmwareRel);

  //Trigger config:
  //  ret |= CAEN_DGTZ_SetSWTriggerMode(handle,CAEN_DGTZ_TRGMODE_DISABLED);   //No software triggers
  ret |= CAEN_DGTZ_SetSWTriggerMode(handle,CAEN_DGTZ_TRGMODE_ACQ_AND_EXTOUT);   //No software triggers
  ret |= CAEN_DGTZ_SetExtTriggerInputMode(handle,CAEN_DGTZ_TRGMODE_ACQ_AND_EXTOUT); //Use and transmit external trigger
  //  ret |= CAEN_DGTZ_SetExtTriggerInputMode(handle,CAEN_DGTZ_TRGMODE_DISABLED); //No external triggers
  ret |= CAEN_DGTZ_SetIOLevel (handle,CAEN_DGTZ_IOLevel_NIM);
  //  ret |= CAEN_DGTZ_SetChannelTriggerThreshold(handle,0,32768); 

  /*
  //Configure channel self-triggering
  ret |= CAEN_DGTZ_SetChannelSelfTrigger(handle,CAEN_DGTZ_TRGMODE_ACQ_AND_EXTOUT,1);
  ret |= CAEN_DGTZ_SetChannelTriggerThreshold(handle,0,540); 
  ret |= CAEN_DGTZ_SetChannelPulsePolarity(handle,0,CAEN_DGTZ_PulsePolarityNegative);
  ret |= CAEN_DGTZ_SetTriggerPolarity (handle,0,CAEN_DGTZ_TriggerOnFallingEdge);
  */


  //  ret |= CAEN_DGTZ_SetChannelTriggerThreshold(handle,0,512);                 
  // ret |= CAEN_DGTZ_SetChannelSelfTrigger(handle,CAEN_DGTZ_TRGMODE_ACQ_ONLY,1); 


  //Channel configuration:
  ret |= CAEN_DGTZ_SetChannelEnableMask(handle,15);        /* Enable channel 0,1,2 */

  //Samples configuration
  ret |= CAEN_DGTZ_SetRecordLength(handle,49);     /* Set the lenght of each waveform (in samples) */
  CAEN_DGTZ_SetPostTriggerSize(handle,0); 


  //Buffers organization
  reg = 0x800C;
  data = 0;
  data = data | (0x1 << 3); //
  data = data | (0x1 << 1); // 
  CAEN_DGTZ_WriteRegister(handle,reg,data );


  //Readout/IO configuration
  ret |= CAEN_DGTZ_SetMaxNumEventsBLT(handle,1024);     /* Set the max number of events to transfer in a sigle readout */

  
  //Interrupts configuration
#ifdef USE_INTERRUPTS
  CAEN_DGTZ_SetInterruptConfig(handle,CAEN_DGTZ_ENABLE,1,0,INT_N_EVENTS,CAEN_DGTZ_IRQ_MODE_RORA);
#endif

  /*
  //Interruption based reading
  reg = 0xEF00;
  CAEN_DGTZ_ReadRegister(handle,reg,&data );
  printf("Register %X content: %x\n",reg,data);
  data |= 8;
  CAEN_DGTZ_WriteRegister(handle,reg,data );
  printf("Register %X corrected content: %x\n",reg,data);
  */
  


  //  ret |= CAEN_DGTZ_SetAcquisitionMode(handle,CAEN_DGTZ_S_IN_CONTROLLED);          /* Set the acquisition mode */
  ret |= CAEN_DGTZ_SetAcquisitionMode(handle,CAEN_DGTZ_SW_CONTROLLED);          /* Set the acquisition mode */

  if(ret != CAEN_DGTZ_Success) {
    printf("Errors during Digitizer Configuration.\n");
    return 0;
  }
  

  //Initialize the readout buffer - automatic size calculation:
  ret |= CAEN_DGTZ_MallocReadoutBuffer(handle, &buffer, &size);
  printf("Allocated data buffer with size: %d\n",size);

  mybuf = malloc(600000000); //~200MB buffer
  if(mybuf == NULL ) {
    return 0;
  }
  printf("Allocated memory buffer with size 200MB\n");

  mybsize = malloc(1000000*sizeof(int)); //array for the buf sizes
  if(mybsize == NULL ) {
    return 0;
  }
  printf("Allocated buffer for transfer sizes storage\n");
  

  mybufsize = 0;
  
  

  tot_size = 0.;
  count = 0;
  numEvents=0;

  tbeg=tim = time(0);
  tt  = localtime(&tim);
  printf("TIME START   %d : %d \n",tt->tm_min, tt->tm_sec);





  gettimeofday(&tv_beg,NULL);
  //Start of the acquisition
  //  ret |= CAEN_DGTZ_SWStartAcquisition(handle);


  //Another function to start the acquisition - enabling the trigger count:

  reg = 0x8100;
  data = 0;
  data = data | (0x1 << 3); //Count all triggers
  data = data | (0x1 << 2); //Acquisition RUN

  CAEN_DGTZ_WriteRegister(handle,reg,data );

  


  //Polling based reading
#ifndef USE_INTERRUPTS
  for( k=0;k<N_READS;k++) {
  // while(1){
    //ret |= CAEN_DGTZ_SendSWtrigger(handle); /* Send a SW Trigger */
    
    //    ret |= CAEN_DGTZ_ReadData(handle,CAEN_DGTZ_SLAVE_TERMINATED_READOUT_MBLT,buffer,&bsize); 
    ret |= CAEN_DGTZ_ReadData(handle,CAEN_DGTZ_SLAVE_TERMINATED_READOUT_MBLT,&mybuf[mybufsize],&mybsize[k]); 
    mybufsize += mybsize[k];
    
    continue;
   
    //printf("Buffer size: %d\n",bsize);

    ret |= CAEN_DGTZ_GetNumEvents(handle,&mybuf[mybufsize],bsize,&numEvents);
    //    ret |= CAEN_DGTZ_GetNumEvents(handle,buffer,bsize,&numEvents);
    tot_size += (bsize)/(1024.*1024.);
    

    if(numEvents>=1) { 
      // printf("Read %d events\n",numEvents);
      count +=numEvents;
      
      if(0)
      for (i=0;i<numEvents;i++) {
	/* Get the Infos and pointer to the event */
	ret |= CAEN_DGTZ_GetEventInfo(handle,buffer,bsize,i,&eventInfo,&evtptr);
	
	/* Decode the event to get the data */
	ret |= CAEN_DGTZ_DecodeEvent(handle,evtptr,&Evt);
	//*************************************
	// Event Elaboration
	//*************************************
	ret |= CAEN_DGTZ_FreeEvent(handle,&Evt);
      }
    
    }
  }
  

#else


  for(k=0;k<N_READS;k++) {
    ret = CAEN_DGTZ_IRQWait(handle,10000); //Wait for an interruption request, timeout 100s
    //printf("Interrupt recieved: %d\n",ret);
    ret |= CAEN_DGTZ_ReadData(handle,CAEN_DGTZ_SLAVE_TERMINATED_READOUT_MBLT,&mybuf[mybufsize],&mybsize[k]);
    mybufsize += mybsize[k];
    ret=CAEN_DGTZ_SetInterruptConfig(handle,CAEN_DGTZ_DISABLE,1,0,INT_N_EVENTS,CAEN_DGTZ_IRQ_MODE_RORA);
    // printf("Interrupt acknoledged: %d\n",ret);
    CAEN_DGTZ_SetInterruptConfig(handle,CAEN_DGTZ_ENABLE,1,0,INT_N_EVENTS,CAEN_DGTZ_IRQ_MODE_RORA);

    //    ret = CAEN_DGTZ_IACKCycle( handle,&board_id);


    //CAEN_DGTZ_RearmInterrupt (handle);
  }

  
#endif


  CAEN_DGTZ_SWStopAcquisition(handle);
  gettimeofday(&tv_end,NULL);


  dt = time_diff(&tv_beg,&tv_end);

  tend=tim = time(0);
  tt  = localtime(&tim);


  //Process time:
  
  


  //checks on the data:
  printf("Number of events transferred\n");
  for(i=0;i<k;i++) {
    CAEN_DGTZ_GetNumEvents(handle,&mybuf[pos],mybsize[i],&numEvents);
    pos+=mybsize[i];
    printf("%d\t",numEvents);
    if( i%8 ==7) printf("\n");
    count += numEvents;
    //    tot_size += mybsize[i]/(1024.*1024.);
  }
  printf("\n");

  printf("mybufsize: %d, last position: %d\n",mybufsize,pos);

  tot_size = mybufsize /(1024.*1024.);

  printf("Postprocessing:\n");
  CAEN_DGTZ_GetNumEvents(handle,mybuf,mybufsize,&numEvents);
  printf("Number of events sum: %d \t Number of events in buffer: %d\n",count,numEvents);
  
  
  nmissed_ev=0;
  iprev_ev=0;
  if(0)
  for(i=0;i<numEvents;i++) {
    /* Get the Infos and pointer to the event */
    ret |= CAEN_DGTZ_GetEventInfo(handle,mybuf,mybufsize,i,&eventInfo,&evtptr);
    /*
    if(iprev_ev == -1) {
      iprev_ev = 1;
    } else 
    */
    //printf("EventCounter: %d\n",eventInfo.EventCounter);
    if(eventInfo.EventCounter - iprev_ev != 1) {
      nmissed_ev++;
      printf("Event number mismatch: prev %d, curr %d\n",iprev_ev,eventInfo.EventCounter);
    }
    
    iprev_ev = eventInfo.EventCounter;
  }

  ret |= CAEN_DGTZ_GetEventInfo(handle,mybuf,mybufsize,numEvents-1,&eventInfo,&evtptr);

  printf("numEvents: %d, nmissed_ev: %d, eventInfo.EventCounter: %d\n",
	 numEvents,nmissed_ev,eventInfo.EventCounter);

  nmissed_ev = eventInfo.EventCounter - numEvents;
  
  if(nmissed_ev>0) {
    printf("========= Event number differs - numEvents: %d, nmissed_ev: %d, eventInfo.EventCounter: %d\n",
	   numEvents,nmissed_ev,eventInfo.EventCounter);
  }


  
  
  printf("TIME END    %d : %d \n",tt->tm_min, tt->tm_sec);
  printf("Total number of events: %d, Total size read: %lf MB\n",count,tot_size);
  if(dt>0) {
    printf("Time: %d s, time: %f s, Transfer rate: %7.2f MB/s\n",(tend-tbeg),dt,tot_size/dt);
    printf("Total rate: %7.2f ev/s\n",count/dt);
  }

  //Write data to file:
  printf("Writing to file\n");
  sprintf(ofname,"rawdata_%d_%d_%d_%d_%d_%d",tt->tm_year+1900,tt->tm_mon,tt->tm_mday,tt->tm_hour,tt->tm_min, tt->tm_sec);
  // filehandle = open(ofname,O_CREAT |O_WRONLY,S_IRUSR|S_IWUSR);
  //  write(filehandle,mybuf,mybufsize);
  //close(filehandle);      
  free(mybuf);
  free(mybsize);

  //Exit the DAQ
  ret|=CAEN_DGTZ_Reset (handle);

  ret |= CAEN_DGTZ_CloseDigitizer(handle);
  ret |= CAEN_DGTZ_FreeReadoutBuffer(&buffer);

  return 0;
}
